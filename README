
# QEMU_STM32 README
===================

QEMU is a generic and open source machine & userspace emulator and
virtualizer.

This repo started as a clone from here, https://github.com/rurban/qemu-stm32/tree/stm32


# To build
mkdir arm_stm32; cd arm_stm32
../qemu-stm32/configure --disable-werror --enable-debug --target-list="arm-softmmu"     --extra-cflags=-DSTM32_UART_NO_BAUD_DELAY

# Available machines 
-m tsmv2 and -m tsmpro

# To run

TSMV2

 ./arm-softmmu/qemu-system-arm -rtc base=localtime -machine tsmv2  -S -s   -kernel firmware_230.bin  -serial file:uart1.log -serial tcp::12344,server,nowait -serial tcp::12345,server,nowait  -d unimp,guest_errors

TSMPRO

 ./arm-softmmu/qemu-system-arm -rtc base=localtime -machine tsmpro  -S -s   -kernel firmware_265.bin  -serial file:uart1.log -serial tcp::12344,server,nowait -serial tcp::12345,server,nowait  -d unimp,guest_errors  -monitor stdio -trace "stm32*"


arm-none-eabi-gdb build/airsensor_d/firmware/bin/firmware_346.elf  -ex 'target extended-remote 192.168.4.1:2345'
or
gdb-multiarch  build/airsensor_d/firmware/bin/firmware_346.elf  -ex 'target extended-remote 192.168.4.1:2345'

# Attach to uart,
nc 127.0.0.1 12344


# Unimplemeted devices,
Now it should work, but we need more testing.
ASIC SPI:s will be added soon.

If you start qemu manually you can use this to launch the debugger
# launch.json
        {
            "name": "Cortex external qemu Debug",
            "cwd": "${workspaceFolder}",
            "executable": "./build/airsensor_d/firmware/bin/firmware_230.elf",
            "gdbPath": "/usr/bin/gdb-multiarch",
            "request": "attach",
            "type": "cortex-debug",
            "runToEntryPoint": "main",
            "runToMain": true,
            "showDevDebugOutput": "raw",
            "servertype": "external",
            "gdbTarget": "127.0.0.1:1234",
            "host": "localhost",
            "interface": "tcp",
            "port": 2345
        }
